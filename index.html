<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Capra10k - Goat Barn Labeler</title>
  <script src="https://unpkg.com/konva@9.0.0/konva.min.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: #f5f7fa;
      color: #2d3748;
      overflow: hidden;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* Header */
    .header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 16px 24px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 100;
    }

    .header h1 {
      font-size: 1.5rem;
      font-weight: 700;
      letter-spacing: -0.5px;
    }

    .image-counter {
      background: rgba(255,255,255,0.2);
      padding: 6px 14px;
      border-radius: 16px;
      font-weight: 600;
      font-size: 13px;
      backdrop-filter: blur(10px);
    }

    /* Toolbar */
    .toolbar {
      background: white;
      border-bottom: 1px solid #e2e8f0;
      padding: 12px 20px;
      display: flex;
      align-items: center;
      gap: 16px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.05);
      flex-wrap: wrap;
    }

    .toolbar-section {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .toolbar-label {
      font-size: 12px;
      font-weight: 600;
      color: #718096;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    /* Category Dropdown */
    .category-select {
      padding: 8px 32px 8px 12px;
      background: white;
      border: 2px solid #e2e8f0;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 500;
      color: #2d3748;
      cursor: pointer;
      transition: all 0.15s ease;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%234a5568' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 10px center;
      min-width: 150px;
    }

    .category-select:hover {
      border-color: #cbd5e0;
      background-color: #f7fafc;
    }

    .category-select:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }

    /* Colorblind-friendly option colors */
    .category-select option[value="goat"] { color: #e63946; font-weight: 600; }
    .category-select option[value="trough"] { color: #457b9d; font-weight: 600; }
    .category-select option[value="platform"] { color: #f77f00; font-weight: 600; }
    .category-select option[value="enrichment"] { color: #9d4edd; font-weight: 600; }

    /* Toolbar Icon Buttons */
    .toolbar-btn {
      padding: 8px 12px;
      background: white;
      border: 1px solid #e2e8f0;
      border-radius: 6px;
      font-size: 13px;
      color: #4a5568;
      cursor: pointer;
      transition: all 0.15s ease;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      white-space: nowrap;
    }

    .toolbar-btn:hover {
      background: #f7fafc;
      border-color: #cbd5e0;
    }

    .toolbar-btn:active {
      transform: translateY(1px);
    }

    .toolbar-divider {
      width: 1px;
      height: 24px;
      background: #e2e8f0;
      margin: 0 4px;
    }

    .toolbar-spacer {
      flex: 1;
    }

    /* 2-Column Layout */
    .studio-container {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    .section {
      margin-bottom: 24px;
    }

    .section-title {
      font-size: 11px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.8px;
      color: #718096;
      margin-bottom: 10px;
      padding-left: 4px;
    }

    /* Workspace - Now Full Width */
    .workspace {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #fafbfc;
      padding: 20px;
      position: relative;
    }

    #container {
      max-width: 100%;
      max-height: 100%;
      border: 2px solid #cbd5e0;
      background: white;
      box-shadow: 0 10px 40px rgba(0,0,0,0.08);
      border-radius: 8px;
      overflow: hidden;
    }

    /* Right Column - Actions & Info (Narrower) */
    .actions-panel {
      width: 240px;
      background: white;
      border-left: 1px solid #e2e8f0;
      overflow-y: auto;
      padding: 20px 16px;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    /* Primary Action */
    .btn-primary {
      width: 100%;
      padding: 14px 16px;
      background: linear-gradient(135deg, #48c774 0%, #2c9653 100%);
      border: none;
      border-radius: 8px;
      color: white;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 4px 14px rgba(56, 161, 105, 0.3);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(56, 161, 105, 0.4);
    }

    .btn-primary:active {
      transform: translateY(0);
    }

    /* Secondary Action */
    .btn-secondary {
      width: 100%;
      padding: 12px 16px;
      background: white;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      color: #4a5568;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .btn-secondary:hover {
      border-color: #cbd5e0;
      background: #f7fafc;
    }

    /* Navigation Buttons in Toolbar */
    .nav-btn {
      padding: 8px 12px;
      background: white;
      border: 1px solid #e2e8f0;
      border-radius: 6px;
      color: #4a5568;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s ease;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .nav-btn:hover:not(:disabled) {
      background: #f7fafc;
      border-color: #cbd5e0;
    }

    .nav-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    /* Info Panel */
    .info-panel {
      background: #f7fafc;
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      padding: 12px;
      font-size: 12px;
      color: #4a5568;
      line-height: 1.6;
    }

    .info-panel strong {
      color: #2d3748;
      display: block;
      margin-bottom: 4px;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    /* Collapsible Help */
    .help-toggle {
      width: 100%;
      padding: 10px 12px;
      background: white;
      border: 1px solid #e2e8f0;
      border-radius: 6px;
      color: #4a5568;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: all 0.15s ease;
    }

    .help-toggle:hover {
      background: #f7fafc;
      border-color: #cbd5e0;
    }

    .help-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }

    .help-content.open {
      max-height: 300px;
      margin-top: 12px;
    }

    .help-content .info-panel {
      margin-bottom: 0;
    }

    .review-link {
      display: block;
      text-align: center;
      padding: 12px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      text-decoration: none;
      border-radius: 6px;
      font-weight: 600;
      font-size: 13px;
      transition: all 0.2s ease;
    }

    .review-link:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
    }

    /* Responsive */
    @media (max-width: 1200px) {
      .actions-panel {
        width: 200px;
      }
    }

    @media (max-width: 900px) {
      .toolbar {
        padding: 10px 16px;
        gap: 12px;
      }

      .toolbar-label {
        display: none;
      }

      .studio-container {
        flex-direction: column;
      }

      .actions-panel {
        width: 100%;
        border: none;
        border-top: 1px solid #e2e8f0;
        max-height: 150px;
        padding: 16px;
        flex-direction: row;
        flex-wrap: wrap;
      }

      .actions-panel .section {
        margin-bottom: 0;
      }

      .workspace {
        flex: 1;
      }
    }

    @media (max-width: 768px) {
      .header h1 {
        font-size: 1.2rem;
      }

      .toolbar {
        flex-wrap: wrap;
        gap: 8px;
      }

      .category-select {
        min-width: 120px;
      }

      #container {
        width: 100% !important;
        height: auto !important;
      }
    }
  </style>
</head>
<body>
  <!-- Header -->
  <div class="header">
    <h1>üêê Capra10k Labeler</h1>
    <div class="image-counter" id="image-status">Loading...</div>
  </div>

  <!-- Toolbar -->
  <div class="toolbar">
    <!-- Category Selection -->
    <div class="toolbar-section">
      <span class="toolbar-label">Category:</span>
      <select class="category-select" id="category-select" onchange="setCategory(this.value)">
        <option value="goat">üêê Goat</option>
        <option value="trough">üçΩÔ∏è Trough</option>
        <option value="platform">ü™ú Platform</option>
        <option value="enrichment">üéæ Enrichment</option>
      </select>
    </div>

    <div class="toolbar-divider"></div>

    <!-- Canvas Tools -->
    <div class="toolbar-section">
      <button class="toolbar-btn" onclick="undoLastPoint()" title="Undo last point">‚Ü∂ Undo</button>
      <button class="toolbar-btn" onclick="redoLastPoint()" title="Redo last point">‚Ü∑ Redo</button>
      <button class="toolbar-btn" onclick="resetCanvas()" title="Reset canvas">üóëÔ∏è Reset</button>
    </div>

    <div class="toolbar-spacer"></div>

    <!-- Navigation -->
    <div class="toolbar-section">
      <button class="nav-btn" onclick="previousImage()" id="prev-btn" title="Previous image (‚Üê)">‚óÄ Prev</button>
      <button class="nav-btn" onclick="nextImage()" id="next-btn" title="Next image (‚Üí)">Next ‚ñ∂</button>
    </div>
  </div>

  <!-- 2-Column Studio Layout -->
  <div class="studio-container">
    <!-- Center: Workspace (Full Width) -->
    <div class="workspace">
      <div id="container"></div>
    </div>

    <!-- Right: Actions & Info Panel -->
    <div class="actions-panel">
      <div class="section">
        <div class="section-title">Primary Actions</div>
        <button class="btn-primary" onclick="saveAndNext()">
          ‚úì Save & Next
        </button>
        <button class="btn-secondary" onclick="skipImage()">
          ‚è≠Ô∏è Skip Image
        </button>
      </div>

      <div class="section">
        <a href="review.html" class="review-link">üìã Review Queue</a>
      </div>

      <div class="section" style="margin-top: auto;">
        <button class="help-toggle" onclick="toggleHelp()">
          <span>‚ùì Help & Shortcuts</span>
          <span id="help-arrow">‚ñº</span>
        </button>
        <div class="help-content" id="help-content">
          <div class="info-panel">
            <strong>How to Label</strong>
            Click to place points. Close shape by clicking near the start point. Scroll to zoom, drag points to adjust.

            <strong style="margin-top: 12px;">Keyboard Shortcuts</strong>
            ‚Ä¢ <strong>1-4</strong>: Select category<br>
            ‚Ä¢ <strong>Ctrl+S</strong>: Save & next<br>
            ‚Ä¢ <strong>Space</strong>: Skip image<br>
            ‚Ä¢ <strong>‚Üê ‚Üí</strong>: Navigate<br>
            ‚Ä¢ <strong>Esc</strong>: Reset canvas<br>
            ‚Ä¢ <strong>Right-click</strong>: Delete point
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const width = 800;
    const height = 600;
    const categories = {
      goat: { color: '#e63946', name: 'Goat' },
      trough: { color: '#457b9d', name: 'Trough' },
      platform: { color: '#f77f00', name: 'Platform' },
      enrichment: { color: '#9d4edd', name: 'Enrichment' }
    };

    let currentCategory = 'goat';
    let currentPoints = [];
    let shapes = [];
    let scaleBy = 1.1;
    let undoStack = [];

    let imageList = [];
    let currentImageIndex = 0;
    let currentImageObj = null;

    const stage = new Konva.Stage({
      container: 'container',
      width,
      height,
      draggable: false,
    });

    const imageLayer = new Konva.Layer();
    const drawLayer = new Konva.Layer();
    stage.add(imageLayer);
    stage.add(drawLayer);

    // Zoom functionality
    stage.on('wheel', (e) => {
      e.evt.preventDefault();

      const oldScale = stage.scaleX();
      const pointer = stage.getPointerPosition();
      const mousePointTo = {
        x: (pointer.x - stage.x()) / oldScale,
        y: (pointer.y - stage.y()) / oldScale,
      };

      const newScale = e.evt.deltaY < 0 ? oldScale * scaleBy : oldScale / scaleBy;
      stage.draggable(newScale > 1);
      stage.scale({ x: newScale, y: newScale });

      const newPos = {
        x: pointer.x - mousePointTo.x * newScale,
        y: pointer.y - mousePointTo.y * newScale,
      };
      stage.position(newPos);
      stage.batchDraw();
    });

    // Load images functionality
    async function loadImageList() {
      try {
        const response = await fetch('/api/images');
        imageList = await response.json();
        if (imageList.length > 0) {
          loadCurrentImage();
        } else {
          updateImageStatus('No images found');
        }
      } catch (error) {
        console.error('Error loading image list:', error);
        updateImageStatus('Error loading images');
      }
    }

    function updateImageStatus() {
      const statusElement = document.getElementById('image-status');
      if (imageList.length === 0) {
        statusElement.textContent = 'No images to label';
        return;
      }
      const filename = imageList[currentImageIndex].filename.split('/').pop();
      statusElement.textContent = `Image ${currentImageIndex + 1} of ${imageList.length}: ${filename}`;

      // Update navigation buttons
      document.getElementById('prev-btn').disabled = currentImageIndex === 0;
      document.getElementById('next-btn').disabled = currentImageIndex >= imageList.length - 1;
    }

    function loadCurrentImage() {
      if (currentImageIndex >= imageList.length) {
        updateImageStatus();
        return;
      }

      const currentImage = imageList[currentImageIndex];
      const imageUrl = currentImage.url || `goat_images/${currentImage.filename || currentImage}`;

      currentImageObj = new Image();
      currentImageObj.crossOrigin = "Anonymous";

      currentImageObj.onload = function () {
        imageLayer.destroyChildren();
        const konvaImage = new Konva.Image({
          image: currentImageObj,
          width,
          height,
        });
        imageLayer.add(konvaImage);
        imageLayer.draw();
        updateImageStatus();
      };

      currentImageObj.onerror = function() {
        console.error('Error loading image:', imageUrl);
        imageLayer.destroyChildren();
        const konvaRect = new Konva.Rect({
          width,
          height,
          fill: 'white',
        });
        imageLayer.add(konvaRect);
        imageLayer.draw();
        updateImageStatus();
      };

      currentImageObj.src = imageUrl;
    }

    loadImageList();

    const imageObj = new Image();
    imageObj.crossOrigin = "Anonymous";
    imageObj.onload = function () {
      const konvaImage = new Konva.Image({
        image: imageObj,
        width,
        height,
      });
      imageLayer.add(konvaImage);
      imageLayer.draw();
    };
    imageObj.onerror = function() {
      const konvaRect = new Konva.Rect({
        width,
        height,
        fill: 'white',
      });
      imageLayer.add(konvaRect);
      imageLayer.draw();
    };
    imageObj.src = 'goat1.jpg';

    const polyline = new Konva.Line({
      points: [],
      stroke: categories[currentCategory].color,
      strokeWidth: 2,
      dash: [5, 5],
    });
    drawLayer.add(polyline);

    function setCategory(category) {
      currentCategory = category;
      polyline.stroke(categories[category].color);

      // Update dropdown value
      document.getElementById('category-select').value = category;

      drawLayer.draw();
    }

    function toggleHelp() {
      const content = document.getElementById('help-content');
      const arrow = document.getElementById('help-arrow');
      content.classList.toggle('open');
      arrow.textContent = content.classList.contains('open') ? '‚ñ≤' : '‚ñº';
    }

    function updatePolygon(shape) {
      const polygons = drawLayer.find('Line').filter(line =>
        line !== polyline && line.points().length === shape.points.length
      );
      if (polygons.length > 0) {
        const polygon = polygons[0];
        polygon.points(shape.points);
        polygon.fill(categories[shape.category].color);
        polygon.stroke(categories[shape.category].color);
        polygon.closed(true);
        polygon.opacity(0.5);
        drawLayer.batchDraw();
      }
    }

    function undoLastPoint() {
      if (currentPoints.length > 0) {
        const lastX = currentPoints[currentPoints.length - 2];
        const lastY = currentPoints[currentPoints.length - 1];
        undoStack.push({ x: lastX, y: lastY, color: categories[currentCategory].color });

        currentPoints.splice(-2, 2);

        const points = drawLayer.find('Circle');
        const lastPoint = points[points.length - 1];
        if (lastPoint && !lastPoint.shape) {
          lastPoint.destroy();
        }

        polyline.points(currentPoints);
        drawLayer.draw();
      }
    }

    function redoLastPoint() {
      if (undoStack.length > 0) {
        const lastPoint = undoStack.pop();
        currentPoints.push(lastPoint.x, lastPoint.y);

        const point = createDraggablePoint(
          lastPoint.x,
          lastPoint.y,
          lastPoint.color,
          (currentPoints.length / 2) - 1
        );
        drawLayer.add(point);

        polyline.points(currentPoints);
        drawLayer.draw();
      }
    }

    function removePoint(point, index, shape) {
      if (shape) {
        const newPoints = [...shape.points];
        newPoints.splice(index * 2, 2);

        if (newPoints.length >= 6) {
          shape.points = newPoints;
          updatePolygon(shape);
          point.destroy();

          const shapePoints = drawLayer.find('Circle').filter(p => p.shape === shape);
          shapePoints.forEach((p, i) => {
            p.index = i;
          });
        }
      } else {
        currentPoints.splice(index * 2, 2);
        point.destroy();

        polyline.points(currentPoints);

        const currentPolyPoints = drawLayer.find('Circle').filter(p => !p.shape);
        currentPolyPoints.forEach((p, i) => {
          p.index = i;
        });
      }
      drawLayer.draw();
    }

    function createDraggablePoint(x, y, color, index, shape) {
      const point = new Konva.Circle({
        x: x,
        y: y,
        radius: 3,
        fill: color,
        stroke: 'white',
        strokeWidth: 1,
        draggable: true,
      });

      point.index = index;

      point.on('mouseover', () => {
        document.body.style.cursor = 'move';
        point.strokeWidth(2);
        point.radius(4);
        drawLayer.draw();
      });

      point.on('mouseout', () => {
        document.body.style.cursor = 'default';
        point.strokeWidth(1);
        point.radius(3);
        drawLayer.draw();
      });

      point.on('dragstart', () => {
        point.dragging = true;
      });

      point.on('dragend', () => {
        point.dragging = false;
        drawLayer.draw();
      });

      point.on('dragmove', () => {
        if (shape) {
          shape.points[index * 2] = point.x();
          shape.points[index * 2 + 1] = point.y();
          updatePolygon(shape);
        } else {
          currentPoints[index * 2] = point.x();
          currentPoints[index * 2 + 1] = point.y();
          polyline.points(currentPoints);
        }
        drawLayer.batchDraw();
      });

      point.on('contextmenu', (e) => {
        e.evt.preventDefault();
        removePoint(point, point.index, shape);
      });

      return point;
    }

    stage.on('mousemove', (e) => {
      if (currentPoints.length >= 4) {
        const pos = stage.getRelativePointerPosition();
        const [startX, startY] = currentPoints;
        const distance = Math.sqrt(
          Math.pow(pos.x - startX, 2) + Math.pow(pos.y - startY, 2)
        );

        const points = drawLayer.find('Circle');
        const isDragging = points.some(p => p.dragging);

        if (distance < 20 && !isDragging) {
          document.body.style.cursor = 'pointer';
        } else if (e.target === stage || e.target.getLayer() === imageLayer) {
          document.body.style.cursor = 'default';
        }
      }
    });

    stage.on('click', (e) => {
      const pos = stage.getRelativePointerPosition();

      const points = drawLayer.find('Circle');
      if (points.some(p => p.dragging)) {
        return;
      }

      if (currentPoints.length >= 4) {
        const [startX, startY] = currentPoints;
        const distance = Math.sqrt(
          Math.pow(pos.x - startX, 2) + Math.pow(pos.y - startY, 2)
        );

        if (distance < 20) {
          const polygon = new Konva.Line({
            points: currentPoints,
            fill: categories[currentCategory].color,
            stroke: categories[currentCategory].color,
            strokeWidth: 2,
            closed: true,
            opacity: 0.5,
          });

          const shape = {
            points: [...currentPoints],
            category: currentCategory,
          };
          shapes.push(shape);

          drawLayer.add(polygon);
          polygon.moveToBottom();

          points.forEach(point => {
            if (!point.shape) {
              point.destroy();
            }
          });

          for (let i = 0; i < currentPoints.length; i += 2) {
            const point = createDraggablePoint(
              currentPoints[i],
              currentPoints[i + 1],
              categories[currentCategory].color,
              i / 2,
              shape
            );
            point.shape = shape;
            drawLayer.add(point);
          }

          currentPoints = [];
          polyline.points([]);
          drawLayer.draw();
          undoStack = [];
          return;
        }
      }

      if (e.target !== stage && e.target.getLayer() !== imageLayer) return;

      undoStack = [];
      currentPoints.push(pos.x, pos.y);

      const point = createDraggablePoint(pos.x, pos.y, categories[currentCategory].color, (currentPoints.length / 2) - 1);
      drawLayer.add(point);

      polyline.points(currentPoints);
      drawLayer.draw();
    });

    function resetCanvas() {
      currentPoints = [];
      shapes = [];
      undoStack = [];
      drawLayer.destroyChildren();
      drawLayer.add(polyline);
      drawLayer.draw();
    }

    function previousImage() {
      if (currentImageIndex > 0) {
        currentImageIndex--;
        resetCanvas();
        loadCurrentImage();
      }
    }

    function nextImage() {
      if (currentImageIndex < imageList.length - 1) {
        currentImageIndex++;
        resetCanvas();
        loadCurrentImage();
      }
    }

    function skipImage() {
      nextImage();
    }

    async function saveAndNext() {
      if (shapes.length === 0) {
        alert('No annotations to save. Add some labels first or use Skip to move to the next image.');
        return;
      }

      try {
        await saveAnnotations();

        const filename = imageList[currentImageIndex].filename || imageList[currentImageIndex];
        const isSampleImage = filename.includes('sample') || filename.startsWith('sample_');

        const response = await fetch('/api/move-to-reviewed', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            filename: filename,
            copyOnly: isSampleImage
          }),
        });

        if (response.ok) {
          if (!isSampleImage) {
            imageList.splice(currentImageIndex, 1);

            if (currentImageIndex >= imageList.length && imageList.length > 0) {
              currentImageIndex = imageList.length - 1;
            }
          } else {
            currentImageIndex++;
            if (currentImageIndex >= imageList.length) {
              currentImageIndex = 0;
            }
          }

          if (imageList.length > 0) {
            resetCanvas();
            loadCurrentImage();
          } else {
            updateImageStatus();
            document.getElementById('image-status').textContent = 'All images completed! üéâ';
          }
        } else {
          throw new Error('Failed to move image to review queue');
        }
      } catch (error) {
        console.error('Error saving and moving image:', error);
        alert('Error saving image. Please try again.');
      }
    }

    async function saveAnnotations() {
      const canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext('2d');

      if (currentImageObj) {
        ctx.drawImage(currentImageObj, 0, 0, width, height);
      }

      shapes.forEach(shape => {
        ctx.beginPath();
        ctx.moveTo(shape.points[0], shape.points[1]);
        for (let i = 2; i < shape.points.length; i += 2) {
          ctx.lineTo(shape.points[i], shape.points[i + 1]);
        }
        ctx.closePath();

        const color = categories[shape.category].color;
        const r = parseInt(color.slice(1,3), 16);
        const g = parseInt(color.slice(3,5), 16);
        const b = parseInt(color.slice(5,7), 16);
        ctx.fillStyle = `rgba(${r},${g},${b},0.5)`;
        ctx.fill();
      });

      const maskCanvas = document.createElement('canvas');
      maskCanvas.width = width;
      maskCanvas.height = height;
      const maskCtx = maskCanvas.getContext('2d');

      maskCtx.clearRect(0, 0, width, height);

      shapes.forEach(shape => {
        maskCtx.beginPath();
        maskCtx.moveTo(shape.points[0], shape.points[1]);
        for (let i = 2; i < shape.points.length; i += 2) {
          maskCtx.lineTo(shape.points[i], shape.points[i + 1]);
        }
        maskCtx.closePath();
        maskCtx.fillStyle = categories[shape.category].color;
        maskCtx.fill();
      });

      const currentFilename = imageList[currentImageIndex].filename || imageList[currentImageIndex];
      const baseName = currentFilename.replace(/\.[^/.]+$/, "");

      const overlayData = canvas.toDataURL();
      try {
        await fetch('/api/save-overlay', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            filename: currentFilename,
            overlayData: overlayData
          }),
        });
      } catch (error) {
        console.error('Error saving overlay:', error);
        throw error;
      }

      const maskLink = document.createElement('a');
      maskLink.download = `${baseName}_mask.png`;
      maskLink.href = maskCanvas.toDataURL();
      maskLink.click();
    }

    stage.on('contextmenu', (e) => {
      e.evt.preventDefault();
    });

    document.addEventListener('keydown', (e) => {
      if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
        switch(e.key) {
          case 'ArrowLeft':
            e.preventDefault();
            previousImage();
            break;
          case 'ArrowRight':
            e.preventDefault();
            nextImage();
            break;
          case 's':
          case 'S':
            if (e.ctrlKey || e.metaKey) {
              e.preventDefault();
              saveAndNext();
            }
            break;
          case ' ':
            e.preventDefault();
            skipImage();
            break;
          case 'Escape':
            e.preventDefault();
            resetCanvas();
            break;
          case '1':
            e.preventDefault();
            setCategory('goat');
            break;
          case '2':
            e.preventDefault();
            setCategory('trough');
            break;
          case '3':
            e.preventDefault();
            setCategory('platform');
            break;
          case '4':
            e.preventDefault();
            setCategory('enrichment');
            break;
        }
      }
    });
  </script>
</body>
</html>
