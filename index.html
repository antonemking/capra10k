<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Capra10k - Goat Barn Labeler</title>
  <script src="https://unpkg.com/konva@9.0.0/konva.min.js"></script>
  <style>
    * { box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #f5f7fa;
      margin: 0;
      padding: 0;
      color: #2d3748;
      overflow-x: hidden;
    }

    /* Header */
    .header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 20px 30px;
      box-shadow: 0 2px 12px rgba(0,0,0,0.1);
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 15px;
    }

    .header h1 {
      margin: 0;
      font-size: 1.75rem;
      font-weight: 700;
      letter-spacing: -0.5px;
    }

    .header-right {
      display: flex;
      gap: 15px;
      align-items: center;
    }

    .image-counter {
      background: rgba(255,255,255,0.2);
      padding: 8px 16px;
      border-radius: 20px;
      font-weight: 600;
      font-size: 14px;
      backdrop-filter: blur(10px);
    }

    /* Main Layout */
    .main-container {
      display: flex;
      min-height: calc(100vh - 100px);
      gap: 0;
    }

    /* Sidebar */
    .sidebar {
      width: 280px;
      background: white;
      border-right: 1px solid #e2e8f0;
      padding: 20px;
      overflow-y: auto;
      box-shadow: 2px 0 10px rgba(0,0,0,0.05);
    }

    .control-section {
      margin-bottom: 25px;
    }

    .section-title {
      font-size: 11px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: #718096;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .section-title::before {
      content: '';
      width: 3px;
      height: 12px;
      background: #667eea;
      border-radius: 2px;
    }

    /* Canvas Area */
    .canvas-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 30px;
      background: #fafbfc;
    }

    #container {
      width: 800px;
      height: 600px;
      border: 3px solid #e2e8f0;
      background: white;
      box-shadow: 0 10px 40px rgba(0,0,0,0.1);
      border-radius: 12px;
      overflow: hidden;
    }

    /* Buttons */
    .btn {
      width: 100%;
      padding: 12px 16px;
      cursor: pointer;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      font-size: 14px;
      color: white;
      transition: all 0.2s ease;
      font-family: inherit;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      margin-bottom: 8px;
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }

    .btn:active {
      transform: translateY(0);
    }

    /* Category Buttons */
    .btn.goat-btn {
      background: linear-gradient(135deg, #fc5c7d 0%, #e53e3e 100%);
    }

    .btn.trough-btn {
      background: linear-gradient(135deg, #48c774 0%, #38a169 100%);
    }

    .btn.platform-btn {
      background: linear-gradient(135deg, #f59e0b 0%, #d69e2e 100%);
    }

    .btn.enrichment-btn {
      background: linear-gradient(135deg, #a78bfa 0%, #805ad5 100%);
    }

    /* Tool Buttons */
    .btn.tool-btn {
      background: #e2e8f0;
      color: #2d3748;
      font-weight: 500;
    }

    .btn.tool-btn:hover {
      background: #cbd5e0;
    }

    /* Action Buttons */
    .btn.save-btn {
      background: linear-gradient(135deg, #48c774 0%, #2c9653 100%);
      font-size: 16px;
      padding: 14px 16px;
      box-shadow: 0 4px 14px rgba(56, 161, 105, 0.4);
    }

    .btn.skip-btn {
      background: #ed8936;
    }

    .btn.nav-btn {
      background: #4299e1;
      width: 48%;
      display: inline-flex;
    }

    .btn-group {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
    }

    /* Quick Help */
    .quick-help {
      background: #f7fafc;
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      padding: 12px;
      font-size: 12px;
      color: #4a5568;
      line-height: 1.6;
    }

    .quick-help strong {
      color: #2d3748;
      display: block;
      margin-top: 8px;
      margin-bottom: 4px;
    }

    .quick-help strong:first-child {
      margin-top: 0;
    }

    /* Review Link */
    .review-link {
      display: block;
      text-align: center;
      padding: 14px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      text-decoration: none;
      border-radius: 8px;
      font-weight: 600;
      transition: all 0.2s ease;
    }

    .review-link:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
    }

    /* Footer */
    footer {
      text-align: center;
      padding: 20px;
      background: white;
      border-top: 1px solid #e2e8f0;
      color: #718096;
      font-size: 13px;
    }

    /* Responsive */
    @media (max-width: 1200px) {
      .main-container {
        flex-direction: column;
      }

      .sidebar {
        width: 100%;
        border-right: none;
        border-bottom: 1px solid #e2e8f0;
      }

      #container {
        max-width: 100%;
        width: 100%;
        height: 500px;
      }

      .canvas-area {
        padding: 20px;
      }
    }

    @media (max-width: 768px) {
      .header {
        padding: 15px 20px;
      }

      .header h1 {
        font-size: 1.4rem;
      }

      .sidebar {
        padding: 15px;
      }

      #container {
        height: 400px;
      }
    }
  </style>
</head>
<body>
  <!-- Header -->
  <div class="header">
    <h1>üêê Capra10k Labeler</h1>
    <div class="header-right">
      <div class="image-counter" id="image-status">Loading...</div>
      <a href="review.html" class="review-link" style="padding: 8px 16px; border-radius: 20px; font-size: 14px;">Review Queue</a>
    </div>
  </div>

  <!-- Main Container -->
  <div class="main-container">
    <!-- Sidebar -->
    <div class="sidebar">
      <!-- Label Categories -->
      <div class="control-section">
        <div class="section-title">Label Categories</div>
        <button class="btn goat-btn" onclick="setCategory('goat')">üêê Goat</button>
        <button class="btn trough-btn" onclick="setCategory('trough')">üçΩÔ∏è Trough</button>
        <button class="btn platform-btn" onclick="setCategory('platform')">ü™ú Platform</button>
        <button class="btn enrichment-btn" onclick="setCategory('enrichment')">üéæ Enrichment</button>
      </div>

      <!-- Canvas Tools -->
      <div class="control-section">
        <div class="section-title">Canvas Tools</div>
        <div class="btn-group">
          <button class="btn tool-btn" onclick="undoLastPoint()" style="width: 50%;">‚Ü∂ Undo</button>
          <button class="btn tool-btn" onclick="redoLastPoint()" style="width: 50%;">‚Ü∑ Redo</button>
        </div>
        <button class="btn tool-btn" onclick="resetCanvas()">üóëÔ∏è Reset Canvas</button>
      </div>

      <!-- Navigation -->
      <div class="control-section">
        <div class="section-title">Navigation</div>
        <div class="btn-group">
          <button class="btn nav-btn" onclick="previousImage()">‚óÄ Prev</button>
          <button class="btn nav-btn" onclick="nextImage()">Next ‚ñ∂</button>
        </div>
      </div>

      <!-- Actions -->
      <div class="control-section">
        <div class="section-title">Actions</div>
        <button class="btn save-btn" onclick="saveAndNext()">‚úì Save & Next</button>
        <button class="btn skip-btn" onclick="skipImage()">‚è≠Ô∏è Skip Image</button>
      </div>

      <!-- Quick Help -->
      <div class="control-section">
        <div class="quick-help">
          <strong>How to Label:</strong>
          Click to place points, close shape by clicking near start.
          <strong>Shortcuts:</strong>
          ‚Ä¢ 1-4: Select category<br>
          ‚Ä¢ Ctrl+S: Save & next<br>
          ‚Ä¢ Space: Skip<br>
          ‚Ä¢ ‚Üê ‚Üí: Navigate<br>
          ‚Ä¢ Esc: Reset
        </div>
      </div>
    </div>

    <!-- Canvas Area -->
    <div class="canvas-area">
      <div id="container"></div>
    </div>
  </div>

  <!-- Footer -->
  <footer>
    ¬© 2025 Capra AI. All rights reserved.
  </footer>

  <script>
    const width = 800;
    const height = 600;
    const categories = {
      goat: { color: '#FF0000', name: 'Goat' },
      trough: { color: '#00FF66', name: 'Trough' },
      platform: { color: '#8B4513', name: 'Platform/Perch' },
      enrichment: { color: '#9370DB', name: 'Enrichment Item' }
    };

    let currentCategory = 'goat';
    let currentPoints = [];
    let shapes = [];
    let scaleBy = 1.1;
    let undoStack = []; // Store removed points for redo
    
    // Image cycling variables
    let imageList = [];
    let currentImageIndex = 0;
    let currentImageObj = null;

    const stage = new Konva.Stage({
      container: 'container',
      width,
      height,
      draggable: false, // Start with dragging disabled
    });

    const imageLayer = new Konva.Layer();
    const drawLayer = new Konva.Layer();
    stage.add(imageLayer);
    stage.add(drawLayer);

    // Zoom functionality
    stage.on('wheel', (e) => {
      e.evt.preventDefault();
      
      const oldScale = stage.scaleX();
      const pointer = stage.getPointerPosition();
      const mousePointTo = {
        x: (pointer.x - stage.x()) / oldScale,
        y: (pointer.y - stage.y()) / oldScale,
      };

      const newScale = e.evt.deltaY < 0 ? oldScale * scaleBy : oldScale / scaleBy;

      // Enable dragging only when zoomed in
      stage.draggable(newScale > 1);

      stage.scale({ x: newScale, y: newScale });

      const newPos = {
        x: pointer.x - mousePointTo.x * newScale,
        y: pointer.y - mousePointTo.y * newScale,
      };
      stage.position(newPos);
      stage.batchDraw();
    });

    // Load images functionality
    async function loadImageList() {
      try {
        const response = await fetch('/api/images');
        imageList = await response.json();
        if (imageList.length > 0) {
          loadCurrentImage();
        } else {
          updateImageStatus('No images found');
        }
      } catch (error) {
        console.error('Error loading image list:', error);
        updateImageStatus('Error loading images');
      }
    }

    function updateImageStatus() {
      const statusElement = document.getElementById('image-status');
      if (imageList.length === 0) {
        statusElement.textContent = 'No images to label';
        return;
      }
      // Extract just the filename from the path for cleaner display
      const filename = imageList[currentImageIndex].filename.split('/').pop();
      statusElement.textContent = `Image ${currentImageIndex + 1} of ${imageList.length}: ${filename}`;
    }

    function loadCurrentImage() {
      if (currentImageIndex >= imageList.length) {
        updateImageStatus();
        return;
      }

      // Get the current image object from the list
      const currentImage = imageList[currentImageIndex];
      const imageUrl = currentImage.url || `goat_images/${currentImage.filename || currentImage}`;

      // Create new image object
      currentImageObj = new Image();
      currentImageObj.crossOrigin = "Anonymous";

      currentImageObj.onload = function () {
        // Clear the image layer
        imageLayer.destroyChildren();

        const konvaImage = new Konva.Image({
          image: currentImageObj,
          width,
          height,
        });
        imageLayer.add(konvaImage);
        imageLayer.draw();
        updateImageStatus();
      };

      currentImageObj.onerror = function() {
        console.error('Error loading image:', imageUrl);
        // Create a fallback white background
        imageLayer.destroyChildren();
        const konvaRect = new Konva.Rect({
          width,
          height,
          fill: 'white',
        });
        imageLayer.add(konvaRect);
        imageLayer.draw();
        updateImageStatus();
      };

      currentImageObj.src = imageUrl;
    }

    // Initialize the application
    loadImageList();

    // Load the image
    const imageObj = new Image();
    imageObj.crossOrigin = "Anonymous";
    imageObj.onload = function () {
      const konvaImage = new Konva.Image({
        image: imageObj,
        width,
        height,
      });
      imageLayer.add(konvaImage);
      imageLayer.draw();
    };
    imageObj.onerror = function() {
      console.error('Error loading image. Make sure the image is served with proper CORS headers.');
      // Create a fallback white background
      const konvaRect = new Konva.Rect({
        width,
        height,
        fill: 'white',
      });
      imageLayer.add(konvaRect);
      imageLayer.draw();
    };
    imageObj.src = 'goat1.jpg';

    // Current polygon line
    const polyline = new Konva.Line({
      points: [],
      stroke: categories[currentCategory].color,
      strokeWidth: 2,
      dash: [5, 5],
    });
    drawLayer.add(polyline);

    function setCategory(category) {
      currentCategory = category;
      polyline.stroke(categories[category].color);
      drawLayer.draw();
    }

    function updatePolygon(shape) {
      // Find and update the polygon visual
      const polygons = drawLayer.find('Line').filter(line => 
        line !== polyline && line.points().length === shape.points.length
      );
      if (polygons.length > 0) {
        const polygon = polygons[0];
        polygon.points(shape.points);
        polygon.fill(categories[shape.category].color);
        polygon.stroke(categories[shape.category].color);
        polygon.closed(true);
        polygon.opacity(0.5);
        drawLayer.batchDraw();
      }
    }

    function undoLastPoint() {
      if (currentPoints.length > 0) {
        // Store the point for redo
        const lastX = currentPoints[currentPoints.length - 2];
        const lastY = currentPoints[currentPoints.length - 1];
        undoStack.push({ x: lastX, y: lastY, color: categories[currentCategory].color });
        
        // Remove the last point from the array
        currentPoints.splice(-2, 2);
        
        // Remove the last point visual
        const points = drawLayer.find('Circle');
        const lastPoint = points[points.length - 1];
        if (lastPoint && !lastPoint.shape) {
          lastPoint.destroy();
        }
        
        // Update the polyline
        polyline.points(currentPoints);
        drawLayer.draw();
      }
    }

    function redoLastPoint() {
      if (undoStack.length > 0) {
        const lastPoint = undoStack.pop();
        
        // Add the point back
        currentPoints.push(lastPoint.x, lastPoint.y);
        
        // Create the point visual
        const point = createDraggablePoint(
          lastPoint.x,
          lastPoint.y,
          lastPoint.color,
          (currentPoints.length / 2) - 1
        );
        drawLayer.add(point);
        
        // Update the polyline
        polyline.points(currentPoints);
        drawLayer.draw();
      }
    }

    function removePoint(point, index, shape) {
      if (shape) {
        // Remove point from completed shape
        const newPoints = [...shape.points];
        newPoints.splice(index * 2, 2);
        
        if (newPoints.length >= 6) { // Keep shape if at least 3 points remain
          shape.points = newPoints;
          updatePolygon(shape);
          point.destroy();
          
          // Reindex remaining points
          const shapePoints = drawLayer.find('Circle').filter(p => p.shape === shape);
          shapePoints.forEach((p, i) => {
            p.index = i;
          });
        }
      } else {
        // Remove point from current polygon
        currentPoints.splice(index * 2, 2);
        point.destroy();
        
        // Update the polyline
        polyline.points(currentPoints);
        
        // Reindex remaining points
        const currentPolyPoints = drawLayer.find('Circle').filter(p => !p.shape);
        currentPolyPoints.forEach((p, i) => {
          p.index = i;
        });
      }
      drawLayer.draw();
    }

    function createDraggablePoint(x, y, color, index, shape) {
      const point = new Konva.Circle({
        x: x,
        y: y,
        radius: 3,
        fill: color,
        stroke: 'white',
        strokeWidth: 1,
        draggable: true,
      });

      point.index = index; // Store the index on the point
      
      // Add hover cursor and visual feedback
      point.on('mouseover', () => {
        document.body.style.cursor = 'move';
        point.strokeWidth(2);
        point.radius(4);
        drawLayer.draw();
      });

      point.on('mouseout', () => {
        document.body.style.cursor = 'default';
        point.strokeWidth(1);
        point.radius(3);
        drawLayer.draw();
      });

      point.on('dragstart', () => {
        point.dragging = true;
      });

      point.on('dragend', () => {
        point.dragging = false;
        drawLayer.draw();
      });

      point.on('dragmove', () => {
        if (shape) {
          shape.points[index * 2] = point.x();
          shape.points[index * 2 + 1] = point.y();
          updatePolygon(shape);
        } else {
          currentPoints[index * 2] = point.x();
          currentPoints[index * 2 + 1] = point.y();
          polyline.points(currentPoints);
        }
        drawLayer.batchDraw();
      });

      // Add right-click to delete point
      point.on('contextmenu', (e) => {
        e.evt.preventDefault();
        removePoint(point, point.index, shape);
      });

      return point;
    }

    stage.on('mousemove', (e) => {
      // Change cursor when near the first point
      if (currentPoints.length >= 4) { // At least 2 points
        const pos = stage.getRelativePointerPosition();
        const [startX, startY] = currentPoints;
        const distance = Math.sqrt(
          Math.pow(pos.x - startX, 2) + Math.pow(pos.y - startY, 2)
        );
        
        // Only show pointer cursor if we're not currently dragging a point
        const points = drawLayer.find('Circle');
        const isDragging = points.some(p => p.dragging);
        
        if (distance < 20 && !isDragging) {
          document.body.style.cursor = 'pointer';
        } else if (e.target === stage || e.target.getLayer() === imageLayer) {
          document.body.style.cursor = 'default';
        }
      }
    });

    stage.on('click', (e) => {
      const pos = stage.getRelativePointerPosition();
      
      // Don't handle clicks if we're dragging a point
      const points = drawLayer.find('Circle');
      if (points.some(p => p.dragging)) {
        return;
      }

      // Check if clicking near the first point to close the polygon
      if (currentPoints.length >= 4) { // At least 2 points
        const [startX, startY] = currentPoints;
        const distance = Math.sqrt(
          Math.pow(pos.x - startX, 2) + Math.pow(pos.y - startY, 2)
        );

        if (distance < 20) {
          // Create filled polygon
          const polygon = new Konva.Line({
            points: currentPoints,
            fill: categories[currentCategory].color,
            stroke: categories[currentCategory].color,
            strokeWidth: 2,
            closed: true,
            opacity: 0.5,
          });
          
          const shape = {
            points: [...currentPoints],
            category: currentCategory,
          };
          shapes.push(shape);
          
          drawLayer.add(polygon);
          polygon.moveToBottom(); // Move polygon behind points
          
          // Remove the temporary points
          points.forEach(point => {
            if (!point.shape) {
              point.destroy();
            }
          });
          
          // Add draggable points for the completed polygon
          for (let i = 0; i < currentPoints.length; i += 2) {
            const point = createDraggablePoint(
              currentPoints[i],
              currentPoints[i + 1],
              categories[currentCategory].color,
              i / 2,
              shape
            );
            point.shape = shape; // Mark this point as belonging to a shape
            drawLayer.add(point);
          }
          
          // Reset current polygon
          currentPoints = [];
          polyline.points([]);
          drawLayer.draw();
          undoStack = []; // Clear undo stack when completing shape
          return;
        }
      }

      // Only handle clicks on the stage or image layer for new points
      if (e.target !== stage && e.target.getLayer() !== imageLayer) return;
      
      undoStack = []; // Clear undo stack when adding new points
      currentPoints.push(pos.x, pos.y);
      
      // Draw draggable point at click
      const point = createDraggablePoint(pos.x, pos.y, categories[currentCategory].color, (currentPoints.length / 2) - 1);
      drawLayer.add(point);

      // Update polyline
      polyline.points(currentPoints);
      drawLayer.draw();
    });

    function resetCanvas() {
      currentPoints = [];
      shapes = [];
      undoStack = [];
      drawLayer.destroyChildren();
      drawLayer.add(polyline);
      drawLayer.draw();
    }

    function previousImage() {
      if (currentImageIndex > 0) {
        currentImageIndex--;
        resetCanvas();
        loadCurrentImage();
      }
    }

    function nextImage() {
      if (currentImageIndex < imageList.length - 1) {
        currentImageIndex++;
        resetCanvas();
        loadCurrentImage();
      }
    }

    function skipImage() {
      nextImage();
    }

    async function saveAndNext() {
      if (shapes.length === 0) {
        alert('No annotations to save. Add some labels first or use Skip to move to the next image.');
        return;
      }

      try {
        // Save the annotations
        await saveAnnotations();

        // Auto-detect if this is a sample image (should never be deleted)
        const filename = imageList[currentImageIndex].filename || imageList[currentImageIndex];
        const isSampleImage = filename.includes('sample') || filename.startsWith('sample_');

        // Move or copy the image to review queue
        const response = await fetch('/api/move-to-reviewed', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            filename: filename,
            copyOnly: isSampleImage
          }),
        });

        if (response.ok) {
          // Only remove from list if we moved (not copied)
          // Sample images stay in the list as reference
          if (!isSampleImage) {
            imageList.splice(currentImageIndex, 1);

            // Adjust current index if needed
            if (currentImageIndex >= imageList.length && imageList.length > 0) {
              currentImageIndex = imageList.length - 1;
            }
          } else {
            // Sample image - just move to next image
            currentImageIndex++;
            if (currentImageIndex >= imageList.length) {
              currentImageIndex = 0; // Loop back to start
            }
          }

          // Load next image or show completion message
          if (imageList.length > 0) {
            resetCanvas();
            loadCurrentImage();
          } else {
            updateImageStatus();
            document.getElementById('image-status').textContent = 'All images completed! üéâ';
          }
        } else {
          throw new Error('Failed to move image to review queue');
        }
      } catch (error) {
        console.error('Error saving and moving image:', error);
        alert('Error saving image. Please try again.');
      }
    }

    async function saveAnnotations() {
      const canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext('2d');

      // First draw the background image
      if (currentImageObj) {
        ctx.drawImage(currentImageObj, 0, 0, width, height);
      }

      // Draw all shapes with semi-transparency
      shapes.forEach(shape => {
        ctx.beginPath();
        ctx.moveTo(shape.points[0], shape.points[1]);
        for (let i = 2; i < shape.points.length; i += 2) {
          ctx.lineTo(shape.points[i], shape.points[i + 1]);
        }
        ctx.closePath();
        
        // Set fill style with alpha for transparency
        const color = categories[shape.category].color;
        const r = parseInt(color.slice(1,3), 16);
        const g = parseInt(color.slice(3,5), 16);
        const b = parseInt(color.slice(5,7), 16);
        ctx.fillStyle = `rgba(${r},${g},${b},0.5)`;
        ctx.fill();
      });

      // Create a second canvas for the mask-only version
      const maskCanvas = document.createElement('canvas');
      maskCanvas.width = width;
      maskCanvas.height = height;
      const maskCtx = maskCanvas.getContext('2d');

      // Clear mask canvas with transparent background
      maskCtx.clearRect(0, 0, width, height);

      // Draw shapes on mask canvas with full opacity
      shapes.forEach(shape => {
        maskCtx.beginPath();
        maskCtx.moveTo(shape.points[0], shape.points[1]);
        for (let i = 2; i < shape.points.length; i += 2) {
          maskCtx.lineTo(shape.points[i], shape.points[i + 1]);
        }
        maskCtx.closePath();
        maskCtx.fillStyle = categories[shape.category].color;
        maskCtx.fill();
      });

      // Generate filenames based on current image
      const currentFilename = imageList[currentImageIndex].filename || imageList[currentImageIndex];
      const baseName = currentFilename.replace(/\.[^/.]+$/, ""); // Remove extension
      
      // Save overlay image to server instead of downloading
      const overlayData = canvas.toDataURL();
      try {
        await fetch('/api/save-overlay', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            filename: currentFilename,
            overlayData: overlayData
          }),
        });
      } catch (error) {
        console.error('Error saving overlay:', error);
        throw error;
      }

      // Still download the mask for user reference
      const maskLink = document.createElement('a');
      maskLink.download = `${baseName}_mask.png`;
      maskLink.href = maskCanvas.toDataURL();
      maskLink.click();
    }

    function downloadMask() {
      const canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext('2d');

      // First draw the background image
      ctx.drawImage(imageObj, 0, 0, width, height);

      // Draw all shapes with semi-transparency
      shapes.forEach(shape => {
        ctx.beginPath();
        ctx.moveTo(shape.points[0], shape.points[1]);
        for (let i = 2; i < shape.points.length; i += 2) {
          ctx.lineTo(shape.points[i], shape.points[i + 1]);
        }
        ctx.closePath();
        
        // Set fill style with alpha for transparency
        const color = categories[shape.category].color;
        const r = parseInt(color.slice(1,3), 16);
        const g = parseInt(color.slice(3,5), 16);
        const b = parseInt(color.slice(5,7), 16);
        ctx.fillStyle = `rgba(${r},${g},${b},0.5)`;
        ctx.fill();
      });

      // Create a second canvas for the mask-only version
      const maskCanvas = document.createElement('canvas');
      maskCanvas.width = width;
      maskCanvas.height = height;
      const maskCtx = maskCanvas.getContext('2d');

      // Clear mask canvas with transparent background
      maskCtx.clearRect(0, 0, width, height);

      // Draw shapes on mask canvas with full opacity
      shapes.forEach(shape => {
        maskCtx.beginPath();
        maskCtx.moveTo(shape.points[0], shape.points[1]);
        for (let i = 2; i < shape.points.length; i += 2) {
          maskCtx.lineTo(shape.points[i], shape.points[i + 1]);
        }
        maskCtx.closePath();
        maskCtx.fillStyle = categories[shape.category].color;
        maskCtx.fill();
      });

      // Download both versions
      const overlayLink = document.createElement('a');
      overlayLink.download = 'overlay.png';
      overlayLink.href = canvas.toDataURL();
      overlayLink.click();

      const maskLink = document.createElement('a');
      maskLink.download = 'mask.png';
      maskLink.href = maskCanvas.toDataURL();
      maskLink.click();
    }

    // Prevent context menu on right-click
    stage.on('contextmenu', (e) => {
      e.evt.preventDefault();
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      // Only handle shortcuts if not in an input field
      if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
        switch(e.key) {
          case 'ArrowLeft':
            e.preventDefault();
            previousImage();
            break;
          case 'ArrowRight':
            e.preventDefault();
            nextImage();
            break;
          case 's':
          case 'S':
            if (e.ctrlKey || e.metaKey) {
              e.preventDefault();
              saveAndNext();
            }
            break;
          case ' ': // Space bar
            e.preventDefault();
            skipImage();
            break;
          case 'Escape':
            e.preventDefault();
            resetCanvas();
            break;
          case '1':
            e.preventDefault();
            setCategory('goat');
            break;
          case '2':
            e.preventDefault();
            setCategory('trough');
            break;
          case '3':
            e.preventDefault();
            setCategory('platform');
            break;
          case '4':
            e.preventDefault();
            setCategory('enrichment');
            break;
        }
      }
    });
  </script>
</body>
</html>
